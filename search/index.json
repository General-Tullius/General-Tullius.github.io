[{"content":" 自动操作是系统自带软件，可以将一些重复性的工作自动化。\n 功能使用 Shell脚本接收参数   自变量获取参数\n 自变量获取参数 \n  stdin获取参数  stdin获取参数 \n  故障排除 Shell脚本部分命令不识别  **: command not found \n 查看选择的Shell类型是否合适。 在脚本前面加入source ~/.bash_profile,引入环境变量配置。  ","date":"2021-05-28T13:31:34+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210528111008.webp","permalink":"https://blog.ionosphere.site/p/375e7a13/","title":"自动操作（Automator）"},{"content":" 创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质\n Spring配置方案  在XML中进显式配置 在Java中进行显式配置 隐式的bean发现机制和自动装配  选择Spring装配方案时，要根据实际情况选择自己最喜欢的方式，多种方案还可以搭配使用。要尽可能的使用自动配置机制，显式配置越少越好；当必须要使用显式配置时，优先JavaConfig；只有在想使用便利的XML命名空间而且在JavaConfig中没有同样的实现时，才使用XML。\n自动化装配bean Spring从两个角度来实现自动化装配：\n 组件扫描（Component scanning）：Spring会自动发现应用上下文中所创建的bean。 自动装配（autowiring）：Spring自动满足bean之间的依赖。  创建可被发现的bean 创建组件类 在类上加@Component注解，就表明这个类会作为组件类、并告知了Spring要为这个类创建bean。\npackage soundsystem; import org.springframework.stereotype.Component; @Component public class SgtPeppers implements CompactDisc { private String title = \u0026#34;Sgt. Pepper\u0026#39;s Lonely Hearts Club Band\u0026#34;; private String artist = \u0026#34;The Beatles\u0026#34;; public void play() { System.out.println(\u0026#34;Playing \u0026#34; + title + \u0026#34; by \u0026#34; + artist); } } 开启组件扫描 组件扫描默认不启用，需要显式配置来命令Spring扫描带有@Component注解的类、并为之创建bean。\n  通过Java配置类启用组件扫描\npackage soundsystem; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan public class CDPlayerConfig { } 配置类不需要显式声明bean，只需要@ComponentScan注解即可，默认会扫描配置类相同的包和子包下的加@Component注解的类。\n  通过XML启用组件扫描\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;soundsystem\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt;   设置bean的ID   默认ID\nSpring默认会用首字母变小写的类名作为bean的ID\n  @Component注解参数设置ID @Component注解可以接收一个字符串作为ID\n@Component(\u0026#34;lonelyHeartsClub\u0026#34;) public class SgtPeppers implements CompactDisc { ... }   @Named注解设置ID\npackage soundsystem; import javax.inject.Named; @Named(\u0026#34;lonelyHeartsClub\u0026#34;) public class SgtPeppers implements CompactDisc { ... } @Named与@Component注解在大多数场景中可以相互替换，但是@Component更便于理解意图\n  设置组件扫描的对象 实际项目中组件扫描不能仅仅扫描配置类所在的包，这就要手动指定扫描对象。\n  在@ComponentScan注解指明包名称\n@Configuration @ComponentScan(\u0026#34;soundsystem\u0026#34;) public class CDPlayerConfig {}   更加清晰的表明是在设置基础包\n@Configuration @ComponentScan(basePackages=\u0026#34;soundsystem\u0026#34;) public class CDPlayerConfig {}   指定多个基础包\n@Configuration @ComponentScan(basePackages={\u0026#34;value1\u0026#34;, \u0026#34;value2\u0026#34;}) public class CDPlayerConfig {}   上面的指定方式用String处理基础包名称，类型不安全（not type- safe），很容易在代码重构时出错。@ComponentScan还提供了一种类型安全的处理方式\n@Configuration @ComponentScan(basePackageClasses={CDPlayer.class, DVDPlayer.class}) public class CDPlayerConfig {} bean自动装配的实现  自动装配：让Spring自动满足bean依赖。在自动装配过程中，会在Spring上下文中寻找匹配某个bean需求的其它bean。\n 使用__@Autowired__注解来声明要进行自动装配：\npackage soundsystem; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class CDPlayer implements MediaPlayer { private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) { this.cd = cd; } public void play() { cd.play(); } } 除了构造器,__@AutoWired__注解还可用于类的任何方法上：\n@Autowired public void setCompactDisc(CompactDisc cd) { this.cd = cd; } 在应用上下文创建时，Spring会尝试满足所有__@AutoWired__注解声明的参数依赖。\n 如果有且只有一个bean匹配依赖的需求，那这个bean会被装配。 如果没有匹配的bean，应用上下文创建时会抛出异常。 如果注解设置成**@AutoWired(required=false)**，Spring会尝试自动装配，若没有匹配bean就会让这个bean处于未装配状态，而不会报错（对于可能未装配的bean要注意做null检查）。 如果有多个bean满足以依赖关系，会抛出异常（没有明确指定要选择哪个bean进行自动装配）   @AutoWired注解是Spring特有的，如果不愿意代码中到处使用Spring的特定注解来完成自动装配任务，可以用**@Inject**替换。**@Inject**注解来源于Java依赖注入规范，与**@AutoWired**有细微差别，但是大多数场景可以互相替换。\n   自动扫描和自动装配可以满足大部分应用场景，但是部分场景仍需要显式配置。比如要将第三方库中的组件装配到自己的应用中，此时没办法修改第三方库、增加@Component和@AutoWired**注解，一次要采用显示装配方案。\n 通过Java代码装配bean 创建配置类 package soundsystem; import org.springframework.context.annotation.Configuration; @Configuration public class CDPlayerConfig { } 配置类的关键在于**@Configuration**注解，与自动装配的配置类的区别在于移除了组件扫描注解**@ComponentScan**。\n声明简单的bean @Bean public CompactDisc sgtPeppers() { return new SgtPeppers(); } @Bean表明此方法会返回一个对象，并且这个对象需要注册为Spring应用上下文中的bean。最中产生bean实例的逻辑包含在方法体中。\n 默认情况下bean的ID与带有Bean注解的方法名一致。如果要自己指定可以用@Bean(name=\u0026quot;customName\u0026quot;)注解方式来指定\n 借助JavaConfig实现依赖注入 假设CDPlayerbean依赖于之前声明的beanCompactDisc,则这样装配：\n@Bean public CDPlayer cdPlayer() { return new CDPlayer(sgtPeppers()); }  此处的CompactDisc看似是\n 通过XML装配bean 创建XML配置规范 声明一个简单\u0026lt;bean\u0026gt; 借助构造器注入初始化bean 设置属性 导入和混合配制 在JavaConfig中引入XML配置 在XML配置用引入JavaConfig ","date":"2021-05-27T15:15:20+08:00","permalink":"https://blog.ionosphere.site/p/a6324888/","title":"装配Bean"},{"content":"Spring是什么 Spring是一个为了解决企业级应用开发的复杂性而创建的开源框架。\nSpring降低Java开发复杂性的4种关键策略\n 基于POJO的轻量级和最小侵入性编程； 通过依赖注入和面向接口实现松耦合； 基于切面和惯例进行声明式编程； 通过切面和模板减少样板式代码。  基于POJO Spring代码仍旧是POJO，除了某些类会用到Spring注解，不会感觉到使用Spring的任何痕迹。\n依赖注入（DI） 依赖注入可以使应用对象之间保持松散耦合。\n应用切面 面向切面编程可以把遍布应用各处的功能分离出来，形成可重用组件。面向切面编程往往被定义为促使软件系统实现关注点分离的一项技术。\n使用模板 通过模板封装来消除样板式代码（比如JDBC操作）。\nSpring容器 在Spring中，应用对象生存于Spring容器（container）中。容器负责创建对象，装配它们，配置并管理它们的整个生命周期，从生存到死亡（new到finalize()）。容器是使用DI管理构成应用的组件，它会创建相互协作的组件之间的关联。\nSpring自带了两类容器，bean工厂 和 应用上下文。bean工厂是最简单的容器，提供了基本的DI支持。应用上下文基于bean工厂构建，并提供应用框架级别的服务。bean工厂太过低级，，应用上下文要比bean工厂更受欢迎。\n应用上下文 常见的应用上下文\n   类型 作用     AnnotationConfigApplicationContext 从一个或多个基于Java的配置类中加载Spring应用上下文   AnnotationConfigWebApplicationContext 从一个或多个基于Java的配置类中加载Spring Web应用上下文。   ClassPathXmlApplicationContext 从类路径下的一个或多个XML配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。   FileSystemXmlApplicationContext 从文件系统下的一个或多个XML配置文件中加载上下文定义。   XmlWebApplicationContext 从Web应用下的一个或多个XML配置文件中加载上下文定义。    bean的生命周期  bean的生命周期 \nSpring功能概览 Spring框架通过专注于DI和AOP和消除样板代码来简化企业级Java开发，这只是Spring提供的部分功能。Spring框架是一个庞大的生态圈，它涵盖了多个不同领域，例如Web服务、REST、移动开发以及NoSQL等。\n Spring框架模块示意图 \n","date":"2021-05-20T15:16:06+08:00","permalink":"https://blog.ionosphere.site/p/006e1380/","title":"初步了解Spring"},{"content":"步骤  设计图标  尺寸要求1024*1024的\n创建图片存放目录  mkdir AppIcon.iconset\n名字随便，但是必须有.iconset后缀\n将原图标转为各种尺寸  sips -z 16 16 AppIcon.png --out AppIcon.iconset/icon_16x16.png sips -z 32 32 AppIcon.png --out AppIcon.iconset/icon_16x16@2x.png sips -z 32 32 AppIcon.png --out AppIcon.iconset/icon_32x32.png sips -z 64 64 AppIcon.png --out AppIcon.iconset/icon_32x32@2x.png sips -z 128 128 AppIcon.png --out AppIcon.iconset/icon_128x128.png sips -z 256 256 AppIcon.png --out AppIcon.iconset/icon_128x128@2x.png sips -z 256 256 AppIcon.png --out AppIcon.iconset/icon_256x256.png sips -z 512 512 AppIcon.png --out AppIcon.iconset/icon_256x256@2x.png sips -z 512 512 AppIcon.png --out AppIcon.iconset/icon_512x512.png sips -z 1024 1024 AppIcon.png --out AppIcon.iconset/icon_512x512@2x.png 生成icns文件  iconutil -c icns AppIcon.iconset -o AppIcon.icns\n经过这几个步骤，就生成了可用的App图标，然后在APP的简介界面替换就行了\n效果 原图标\n \n修改后\n \n","date":"2021-04-28T12:19:35+08:00","permalink":"https://blog.ionosphere.site/p/1844ba76/","title":"自制App图标"},{"content":" 首先要明确一点，针对同一个场景的正则表达式并不是唯一的，只要结果正确即可，不要疑惑为什么自己写的正则跟别人的不一样\n 匹配确定的值 值是什么表达式就是什么。\n# 匹配字母‘A’ A 匹配一些值 用方括号将值包裹起来\n# 匹配姓张的和姓王的 [张王]\\w+ # 匹配数字 [0-9] # 匹配中文 [\\u4e00-\\u9fa5] # 区间取非 # ^只有在‘[]’中且紧跟在‘[’之后才表示取非 # 例：非数字 [^0-9]  元字符：有特殊含义的字符，比如在‘[]’中的连字符‘-’，表示取连字符左右两边值之间的内容。若要取元字符本身的含义，需要用转移字符‘\\’进行转义。若用转义字符对普通字符转义，则普通字符将被理解成元字符，比如匹配换行符‘\\n’。\n 匹配所有值 英文句号.\n匹配次数控制 匹配确定的次数 匹配一次 表达式默认匹配一次，不需要做任何特殊操作\n匹配n次 表达式加‘{n}’\n匹配m次到n次 表达式加‘{m,n}’\n匹配不确定的次数 匹配1到多次 表达式加‘+’\n# 匹配一组数字 \\d+ 匹配0到多次 # 匹配0到多个字符 \\w* 匹配0次或1次 表达式加‘?’\n# 匹配网址 https?//[\\w./]+ 边界 单词边界 \\b\n字符串边界 ^\\w+$\n","date":"2021-04-24T21:27:56+08:00","permalink":"https://blog.ionosphere.site/p/6de70ddc/","title":"正则表达式常用规则"},{"content":"客户端终结点配置 \u0026lt;system.serviceModel\u0026gt; \u0026lt;bindings\u0026gt; \u0026lt;basicHttpBinding\u0026gt; \u0026lt;binding name=\u0026#34;MISServiceHttpBinding\u0026#34; maxBufferSize=\u0026#34;2147483647\u0026#34; maxReceivedMessageSize=\u0026#34;2147483647\u0026#34;/\u0026gt; \u0026lt;/basicHttpBinding\u0026gt; \u0026lt;/bindings\u0026gt; \u0026lt;client\u0026gt; ... \u0026lt;/client\u0026gt; \u0026lt;/system.serviceModel\u0026gt; ","date":"2021-04-09T12:03:53+08:00","permalink":"https://blog.ionosphere.site/p/74cc3c3c/","title":"关于Web Service"},{"content":"起步 本章为Git入门。主要讲解为什么Git这么流行，为什么要使用Git，Git如何设置\n 关于版本控制 记录一个或多个文件内容变化，以便将来阅读特定版本修订情况的系统即版本控制系统（VCS）。\n本地版本控制系统 本地版本控制系统大多都是采用某种简单的数据库来记录文件的历次更新差异，如图所示：\n \n其中最流行的一种叫做RCS。RCS的工作原理是在硬盘上保存补丁集（补丁集是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。本地版本控制系统无法让不同系统上的开发者协同工作。\n集中化的版本控制系统 集中化版本控制系统（Centralized Version Control System，CVCS）很好的解决了本地版本控制系统不能让不同系统上的开发者协同工作的问题。CVCS模式：有一个单一的集中管理服务器，保存所有文件的修订版本，协同工作的人都通过客户端连接到这台服务器，取出最新文件或者提交更新。\n \nCVCS的优点：1.项目参与者可以看到其他人在做什么。2.管理人员可以掌控每个参与者的权限。3.管理一个CVCS相较于在各个客户端维护本地数据库要简单。\nCVCS的缺点：中央服务器故障后会影响所有人的工作。\n典型的CVCS：CVS，Subversion，Perforce\u0026hellip;\n分布式版本控制系统 分布式版本控制系统（Distributed Version Control System，DVCS）中，客户端不仅仅提取最新版本的文件，还把代码仓库完整的镜像下来，包括完整的历史记录。在分布式版本控制系统中，任何一处服务器发生故障，事后都可以用任意一个镜像出来的本地仓库恢复。\n \n典型的DVCS：Git，Mercurial，Bazaar，Darcs\u0026hellip;\n Git的诞生 Linux开源社区的BitKeeper（一款DVCS）使用权到期了，他们只好去开发自己的版本控制系统😂，并且给新系统制定了若干目标：\n 速度 简单的设计 对非线性开发模式的强力支持 完全分布式 有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）   Git的工作原理 直接记录快照、而非比较差异 Git和其它版本控制系统的主要差别在于对待数据的方式。其它大部分系统一文件变更列表的方式存储信息，将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。\n \nGit则更像是把数据看作是对小型文件系统的一系列快照。每当你提交更新或者保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git不再重新存储该文件，而是保留一个链接指向之前存储的文件。Git对待数据更像是一个快照流。\n \n近乎所有操作都是本地执行 Giit中大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息，因为本地磁盘上就有项目的完整历史，同时Git是先提交到本地副本，再上传到服务器的，所以即使离线也可以继续进行任何操作。\nGit保证完整性 Git中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在Git不知情时更改任何文件内容或目录内容。\nGit用于计算校验和的机制叫做SHA-1散列（Hash，哈希，把任意长度的输入「又叫做预映射pre-image」通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值）。这是一个由40个16进制字符（0-9，a-f）组成的字符串，基于Git中文件的内容或目录结构计算出来。SHA-1 Hash 看起来是这样的：24b9da6552252987aa493b52f8696cd6d3b00373\nGit中保存的信息都是以文件的Hash值来索引，而不是文件名。\nGit一般只添加数据 你执行的Git操作几乎只向数据库中添加数据，也就是说Git几乎不会执行任何不可恢复操作。\n三种状态  已修改（modified） 已暂存（staged） 已提交（committed）  已修改表示修改了文件，但是还没有保存到数据库。已暂存表示对一个已修改文件的当前版本做了标记使之包含在下次提交的快照中。已提交表示数据已安全的保存在了本地数据库中。\n 安装Git 略\n Git初始配置 Git自带一个 git config 工具来帮助设置控制 Git 外观和行为的配置变量。这些变量主要存储在三个地方：\n /etc/gitconfig 文件：配置针对所有用户。在执行 git config 时带上 \u0026ndash;system选项，就会读写此文件中的配置。 ~/.gitconfig 或 ~/.config/git/config 文件：配置只针对当前用户。可以传递 \u0026ndash;global 选项让 Git 读写此文件。 当前仓库的 Git 目录中的 config 文件（即 .git/config ）：配置针对当前仓库。可以传递 \u0026ndash;local 选项让 Git 强制读写此文件，同时默认情况下也是读取的此文件。  这三个级别的配置都会覆盖上一级的配置，即当前仓库自定义配置优先级最高。\n用户信息 git config --global user.name \u0026#34;Any Tom\u0026#34; git config --global user.email anytom@example.com 文本编辑器 Git 需要用户输入信息时会调用系统默认的编辑器，如果想使用不同的，可以自己配置：\ngit config --global core.edit code ⚠️在 Windows 系统上，如果想使用别的文本编辑器，必须指定完整的可执行文件路径\n查看配置信息 列出所有 Git 当时能找到的配置\ngit config --list 查看某一项配置\ngit config user.name 由于 Git 会从不同的配置文件中读取同一配置变量的值，因此有些时候可能会看到意料之外的值而不知道为啥。此时可以用命令查看该变量的原始值，命令会告诉你是哪一个配置文件最后设置了该值：\ngit config --show-origin user.name  获取帮助 在使用 Git 时，有三种等价的方法可以找到 Git 命令的综合手册：\ngit help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help man git-\u0026lt;verb\u0026gt; 如果不需要全面的手册，只需要可用选项的快捷参考，可用 git \u0026lt;verb\u0026gt; -h 来获取更简明的“help”输出。\n Git基础 本章主要内容：Git 使用过程中的各种基本命令。\n 获取 Git 仓库 通常获取 Git 的方式有两种：\n 将尚未进行版本控制的本地目录转为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。  从本地目录初始化仓库 cd /my_project_path git init 以上命令将创建一个名为 .git 的子目录，目录中包含了初始化 Git 仓库所有的必须文件。此命令执行后只是初始化了一个 Git 仓库，项目中已有的文件不会被跟踪，此时需要开始追踪并进行初始提交。\ngit add *.c git add LICENSE git commit -m \u0026#39;提交消息内容\u0026#39; 克隆现有仓库 git clone \u0026lt;url\u0026gt; \u0026lt;自定义本地仓库名 可选\u0026gt; 克隆仓库时，支持 http(s):// 协议， git:// 协议 或者 SSH 传输协议。\n 记录每次更新到仓库 Git 中文件的变化周期：\n \n检查当前文件状态 git status 此命令会显示当前哪些文件处于什么状态。列出未跟踪、\n跟踪新文件 git add \u0026lt;fileName\u0026gt; 暂存已修改的文件 git add \u0026lt;fileName\u0026gt; 可以看到，新文件的跟踪、已修改文件的暂存都使用 add 操作，所以 add 操作实际上应该理解为：将指定内容标记为待提交状态（放到暂存区）；若暂存后的文件被修改，必须重新 add，否则 git commit 只会提交上次 add时的状态。\n批量操作：\ngit add -A # 提交所有变化 git add -u # 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new) git add . # 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 状态简览 git status --short git status -s git status 命令的输出十分的详细，实际上我们可能并不需要，通过上面的命令，可以得到简洁的状态信息。\n$ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.tx M 表示文件已修改，MM 表示文件暂存后又有修改，A 表示文件是新增的，?? 表示文件未跟踪。在简览时，未暂存的修改和已暂存的修改标识符号一样，但是颜色不同。\n忽略文件 无需纳入 Git 跟踪的文件记录在 .gitignore中\n提交更新 git commit 在 commit 时，Git 会启动编辑器来输入提交说明，使用 git commit -m '提交说明' 可以直接输入提交说明。\n跳过使用暂存区域 git commit -a 使用此命令 Git 会自动把所有已跟踪的文件暂存起来一并提交，从而跳过 git add 步骤。\n移除文件 从 Git 中移除文件：必须要从已跟踪文件清单中移除，然后提交。Git 提供了 git rm 命令，可完成删除文件并将删除操作放入暂存区的操作。如果删除的文件已经修改过，直接 rm 会报错（不论有没有提交到暂存区，都会报错），此时需要使用 git rm -f 命令。如果只是想把某文件从版本库中删除，本地磁盘保留，则需要命令 git rm --cached。\n移动文件 Git 不像其它的一些 VCS 一样支持显式的跟踪文件移动操作。如果要重命名文件，需要用到以下命令：\ngit mv file_from file_to  查看提交历史 git log  撤销操作 上次提交少了几个文件的情况 git commit --amend 此命令会将当前暂存区中的操作追加上次提交中（最终仓库只显示一次提交记录）。\n取消暂存的操作 git reset HEAD \u0026lt;file\u0026gt; 文件修改还保留在本地磁盘，只是不在暂存区。\n撤销对文件的修改 git restore \u0026lt;文件\u0026gt;... 此操作 Git 会用仓库中最近一次提交的版本覆盖本地文件，文件在本地磁盘上的修改会全部被删除（不可通过 Git 恢复）。\n 远程仓库的使用 查看远程仓库对应的简写和对应的 URL。 git remote -v 添加远程仓库并指定一个方便使用的简写 git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt; 指定shortname之后就可以用shortname来代替整个 URL。例如：\ngit fetch \u0026lt;shortname\u0026gt; 从远程仓库中抓取与拉取 git fetch \u0026lt;remote\u0026gt; 此命令只会将最新数据下载到本地仓库，但是不会自动合并，需要手动操作。如果使用 git pull 命令，则会从服务器抓取数据，并尝试自动合并到当前所在的分支。\n推送到远程仓库 # git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; git push orgin master 如果在你 push 之前，有人 push 过，那就要先将他人的 push pull 下来进行合并，然后才能 push。\n查看某个远程仓库 git remote show \u0026lt;remote\u0026gt;  打标签 打标签功能用于给仓库的某一个提交打上标签，以示重要。常用这个功能来标记发布结点\n列出标签 git tag # 可带上 -l 或 --list 创建标签 附注标签 git tag -a v1.0 -m \u0026#34;版本1.0\u0026#34; 轻量标签 git tag v1.1 后期打标签 若某个版本已提交，但是忘了打标签，可以通过 git log 命令找到那个版本的校验和，然后执行命令：\ngit tag -a v0.1 \u0026lt;校验和 可以只输入部分\u0026gt; 共享标签 默认情况下，push 时并不会传送标签到远程仓库，需要显式的推送。\n# 单个标签推送 git push origin \u0026lt;tagname\u0026gt; # 批量推送，会把所有不在远程仓库的标签全部推送上去 git push origin --tags 删除标签 # 第一步 git tag -d v0.1 # 第二步 # 将冒号前的空值推送到远程标签 git push \u0026lt;remote\u0026gt; :refs/tags/v0.1 # 还可写为 git push \u0026lt;remote\u0026gt; --delete v0.1  技巧和窍门 Git 别名 $ git config --global alias.co checkout $ git config --global alias.br branch $ git config --global alias.ci commit $ git config --global alias.st status 在 git commit 时 只需要 git ci\n   ","date":"2021-03-10T22:55:00+08:00","permalink":"https://blog.ionosphere.site/p/a0fa4610/","title":"Pro Git"},{"content":" 开始系统的学习Java基础知识\n 第1章 Java程序设计概述 Java发展简史    版本 年份 语言新特性 类与接口的数量     1.0 1996 语言本身 211   1.1 1997 内部类 477   1.2 1998 strictfp修饰符 1524   1.3 2000 无 1840   1.4 2002 断言 2723   5.0 2004 泛型类、“for each”循环、可变元参数、自动装箱、元数据、枚举、静态导入 3279   6 2006 无 3793   7 2011 基于字符串的switch、钻石操作符、二进制字面量、异常处理改进 4024   8 2014 lambda表达式、包含默认方法的接口、流和日期/时间库 4240    注：当前已发布到版本16\nJava“白皮书”的关键术语  简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性  第2章 Java程序设计环境 安装Java开发工具包（JDK） 相关术语\n   术语名 缩写 解释     Java Development Kit JDK 编写Java程序的程序员使用的软件   Java Runtime Environment JRE 运行Java程序的用户使用的软件   Server JRE —— 在服务器上运行Java程序的软件   Standard Edition SE 用于桌面或简单服务器应用的Java平台   Enterprise Edition EE 用于复杂服务器应用的Java平台   Micro Edition ME 用于手机和其它小型设备的Java平台   Java FX —— 用于图形化用户界面的一个替代工具包，在Oracle的Java SE发布版本中提供   OpenJDK —— Java SE的一个免费开源实现，不包含浏览器集成或JavaFX   Java 2 J2 一个过时的术语，用于描述1998年～2006年之间的Java版本   Software Development Kit SDK 一个过时的术语，用于描述1998年～2006年之间的JDK   Update u Oracle的术语，表示bug修正版本   Netbeans —— Oracle的集成开发环境     这两章简单介绍了Java的一些特点、发展历史和学习Java编程的前期准备工作，接下来开始正式的内容\n 第3章 Java的基本程序设计结构 一个简单的 Java 应用程序 public class FirstSample { public static void main(String args) { System.out.println(“We will not use ‘Hello World!‘“); } } 类名必须以大写字母开头，遵循骆驼命名法。文件名必须与公共类名一致。\n注释 单行注释\n//这是单行注释 System.out.println(“Hello World!“); 多行注释\n/* 这是多行注释的示例 这是多行注释的示例 */ System.out.println(“Hello World!“); 文档注释\n/** *文档注释的写法 */ 数据类型 Java 是一种强类型语言，每个变量都必须声明类型。Java 共有 8 种基本类型，包含 4 种整型、两种浮点类型、1 种用于表示 Unicode 编码字符单元的字符类型 char。\n   基本类型 位数 字节 默认值     int 32 4 0   short 16 2 0   long 64 8 0L   byte 8 1 0   char 16 2 \u0026lsquo;u0000\u0026rsquo;   float 32 4 0f   double 64 8 0d   boolen 1  false    变量 声明变量与初始化 String name = \u0026#34;名字\u0026#34;; 常量 常量即用final关键字修饰的变量，表示这个变量只能被赋值一次。常量名习惯全大写。\n","date":"2021-03-04T23:27:31+08:00","permalink":"https://blog.ionosphere.site/p/a8e95393/","title":"Java核心技术·卷I"},{"content":" 写作时所有标记用的符号都要用英文，文章标点随意\n  标题 语法 #加文字\n# 一级标题 ## 二级标题 ### 三级标题 . . . ###### 六级标题 效果\n 标题 \n一般一级标题是文章的名称，所以在博客中的标题常从二级开始\n 列表 无序列表 语法 -加空格加文字\n- 列表1 - 列表1.1 - 列表1.2 - 列表2 - 列表3 效果\n 无序列表 \n有序列表 语法 数字加.(英文句号)加空格加文字\n1. 列表1 1. 列表1.1 1. 列表1.2 1. 列表2 1. 列表3 列表中数字并不需要自己一个个排序，全写1即可自动生成序号\n效果\n 有序列表 \n 引用 语法 \u0026gt;加空格加引用内容，多行每行都加\n\u0026gt; 登鹳雀楼_百度汉语 \u0026gt; 作者：王之涣 \u0026gt; 白日依山尽，黄河入海流。 \u0026gt; 欲穷千里目，更上一层楼。 效果\n 引用 \n 文字强调 粗体 语法 **要加粗的文字** 或者用_\n**文字** 效果\n粗体\n斜体 语法 *要变斜体的文字* 或者用_\n*文字* 效果\n斜体\n下划线 语法\n\u0026lt;u\u0026gt;文字\u0026lt;/u\u0026gt; 效果\n下划线\n删除线 语法\n# ~ 英文输入法状态下 Shift 加 ESC下面的按键 ~~文字~~ 效果\n删除线\n 分割线 语法\n*** 效果  分割线 \n 图片 语法\n![名称·随便写](图片地址)  网址 语法\n[显示名称](网址) 效果\n百度\n 表格 语法\n| | | | | :--- | :--: | ---: | | | | | | | | | | | | | 说明\n# 两个｜｜之间是一列，需要几列就分隔出来几个 | | | |这一行是表头 | :--- | :--: | ---: |这一行是显示控制行：列左对齐则冒号在左，右对齐冒号在右，居中则两头冒号 | | | |以下行是表格内容，有几行就加几个，单元格内容放在｜｜中间 | | | | | | | | 效果\n   表头 表头 表头     4 5 6   7 8 9   10 11 12    ","date":"2021-03-02T11:59:39+08:00","permalink":"https://blog.ionosphere.site/p/b133175a/","title":"Markdown语法简单教程"},{"content":" ","date":"2021-02-25T09:08:02+08:00","permalink":"https://blog.ionosphere.site/p/7ecba2d8/","title":"杭州市限行信息"},{"content":" ","date":"2021-02-24T20:07:13+08:00","permalink":"https://blog.ionosphere.site/p/2c7767a8/","title":"南阳市限行信息"},{"content":" 使用 hugo new 新建页面时创建的页面由 archetypes/default.md决定\n 永久链接的生成方案是比较简单的，直接对时间 + 文章名生成字符串做一下 md5 然后取任意 4-12 位即可。这样做的话 md5 冲撞概率极小，同时也没有那么大的运算负担。而 Hugo 在永久链接中支持下面这个参数：slug。简单来说，我们可以针对每一篇文章指定一个 slug，然后在 config.toml 中配置 permalinks 包含 slug 参数，就可以生成唯一的永久链接。我们的目的就是对每篇文章自动生成一个 slug。\n修改 archetypes/default.md 添加如下一行：\n---#...slug:{{substr (md5 (printf \u0026#34;%s%s\u0026#34; .Date (replace .TranslationBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title))) 4 8 }}#...--- 参考：Hugo 永久链接\n ","date":"2021-02-24T00:53:53+08:00","permalink":"https://blog.ionosphere.site/p/da23b91d/","title":"Hugo永久链接"},{"content":"实现思路  在一个在线页面内实现拨号逻辑 生成步骤1中的页面地址对应的二维码 设计步骤2中二维码的样式，打印出来  拨号界面简单实现 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;renderer\u0026#34; content=\u0026#34;webkit\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;force-rendering\u0026#34; content=\u0026#34;webkit\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;一键拨号\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;方便、简单、实用\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;联系我挪车\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;margin-top:50px\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;临时停车😊请多关照\u0026lt;/h1\u0026gt; \u0026lt;a href=\u0026#34;tel:{{手机号码}}\u0026#34; class=\u0026#34;btn btn-success btn-lg\u0026#34; style=\u0026#34;font-size:35px;margin-top:20px;\u0026#34;\u0026gt;挪车电话\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;text-align: center;margin-top:50px\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  页面的托管是很容易解决的，Gitee、GitHub都有提供pages服务，国内推荐用gitee\n 优点  可定制性高 使用方便，换号方便 价格便宜  效果展示  \n","date":"2021-02-23T12:25:05+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210228015227.jpeg","permalink":"https://blog.ionosphere.site/p/1a22f05b/","title":"二维码挪车牌"},{"content":"说明 文章中的快捷键针对Windows10，其它版本Windows系统可能不生效\n快捷键    键位 功能     ctrl+c 复制   ctrl+v 粘贴   ctrl+z 撤销   ctrl+a 全选   ctrl+s 保存   ctrl+x 剪切   ctrl+f 查找   ctrl+tab 切换浏览器、文件管理器等多标签软件标签页   ctrl+w 关闭浏览器、文件管理器等多标签软件的当前页面或单窗体软件   ctrl+shift+t 恢复刚关闭的浏览器页面   ctrl+t 创建一个新浏览器标签页   ctrl++ 放大（浏览器、图片浏览、桌面等处都可用）   ctrl+- 缩小（浏览器、图片浏览、桌面等处都可用）   ctrl+alt+delete 打开任务管理器界面   ctrl+p 打印当前文件       win+d 回到桌面（不论打开了多少窗体）   win+L 锁定电脑   win+e 打开文件管理器   win+m 最小化当前窗体   win+数字键 打开固定在任务栏对应顺序的应用    ","date":"2021-02-22T17:17:12+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210222164440.png","permalink":"https://blog.ionosphere.site/p/a2e6bc04/","title":"Windows快捷键"},{"content":"表象 成因 Gitalk默认的GitHub oauth请求反向代理CORS使用的是https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_tokenGitHub项目，该代理只是一个演示项目，由于被滥用，作者决定于2021年1月31日停止开放使用，从而导致了此问题的产生\n解决  在Heroku上部署自己的cros-anywhere\n   1.注册Heroku账号\n  2.fork cros-anywhere项目\n  3.创建Heroku应用\n  4.将自己fork的项目部署创建的Heroku应用\n官方文档 实际上自己通过网页端操作更方便点\n  5.设置白名单防止滥用导致封号\n  6.修改主题中Gitalk相关的代码 增加Gitalk反向代理配置项\n  // 修改主题根目录下config.json文件，增加Gitalk反向代理自定义配置节点，用于自定义配置代理地址 { \u0026#34;customConfig\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;gitalkProxy\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;GitHub登陆\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;Gitalk\u0026#34;, //此处将地址配置成自己的代理服务器 \u0026#34;value\u0026#34;: \u0026#34;https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;input\u0026#34;, \u0026#34;note\u0026#34;: \u0026#34;GitHub验证\u0026#34; } ] } 修改Gitalk初始化代码templates/includes/gitalk.ejs\n\u0026lt;script\u0026gt; window.onload = function() { var gitalk = new Gitalk({ //增加代理参数，赋值读取自定义配置  proxy: \u0026#39;\u0026lt;%= site.customConfig.gitalkProxy %\u0026gt;\u0026#39;, clientID: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.clientId %\u0026gt;\u0026#39;, clientSecret: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.clientSecret %\u0026gt;\u0026#39;, repo: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.repository %\u0026gt;\u0026#39;, owner: \u0026#39;\u0026lt;%= commentSetting.gitalkSetting.owner %\u0026gt;\u0026#39;, admin: [\u0026#39;\u0026lt;%= commentSetting.gitalkSetting.owner %\u0026gt;\u0026#39;], id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50  distractionFreeMode: false // Facebook-like distraction free mode  }) gitalk.render(\u0026#39;gitalk-container\u0026#39;) } \u0026lt;/script\u0026gt; ","date":"2021-02-20T17:59:56+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210220214315.png","permalink":"https://blog.ionosphere.site/p/44c1c716/","title":"Gridea Gitalk 评论登录403问题"},{"content":"Nuget包管理加载版本时报错 解决方案：\n 打开.vscode/extensions/jmrog.vscode-nuget-package-manager-1.1.6/out/src/actions/add-methods/fetchPackageVersions.js， 修改代码 ...node_fetch_1.default(`${versionsUrl}${selectedPackageName.toLowerCase()}/index.json`, utils_1.getFetchOptions(vscode.workspace.getConfiguration(\u0026#39;http\u0026#39;)))   ","date":"2021-02-06T13:19:30+08:00","permalink":"https://blog.ionosphere.site/p/41e58ada/","title":"Visual Studio Code 使用问题记录"},{"content":"#!/usr/bin/python3 # -*- coding: utf-8 -*- import json import requests import math key = \u0026#39;your key here\u0026#39; # 这里填写你的百度开放平台的key x_pi = 3.14159265358979324 * 3000.0 / 180.0 pi = 3.1415926535897932384626 # π a = 6378245.0 # 长半轴 ee = 0.00669342162296594323 # 扁率 def geocode(address): \u0026#34;\u0026#34;\u0026#34; 利用百度geocoding服务解析地址获取位置坐标 :param address:需要解析的地址 :return: \u0026#34;\u0026#34;\u0026#34; geocoding = {\u0026#39;s\u0026#39;: \u0026#39;rsv3\u0026#39;, \u0026#39;key\u0026#39;: key, \u0026#39;city\u0026#39;: \u0026#39;全国\u0026#39;, \u0026#39;address\u0026#39;: address} res = requests.get( \u0026#34;http://restapi.amap.com/v3/geocode/geo\u0026#34;, params=geocoding) if res.status_code == 200: json = res.json() status = json.get(\u0026#39;status\u0026#39;) count = json.get(\u0026#39;count\u0026#39;) if status == \u0026#39;1\u0026#39; and int(count) \u0026gt;= 1: geocodes = json.get(\u0026#39;geocodes\u0026#39;)[0] lng = float(geocodes.get(\u0026#39;location\u0026#39;).split(\u0026#39;,\u0026#39;)[0]) lat = float(geocodes.get(\u0026#39;location\u0026#39;).split(\u0026#39;,\u0026#39;)[1]) return [lng, lat] else: return None else: return None def gcj02tobd09(lng, lat): \u0026#34;\u0026#34;\u0026#34; 火星坐标系(GCJ-02)转百度坐标系(BD-09) 谷歌、高德——\u0026gt;百度 :param lng:火星坐标经度 :param lat:火星坐标纬度 :return: \u0026#34;\u0026#34;\u0026#34; z = math.sqrt(lng * lng + lat * lat) + 0.00002 * math.sin(lat * x_pi) theta = math.atan2(lat, lng) + 0.000003 * math.cos(lng * x_pi) bd_lng = z * math.cos(theta) + 0.0065 bd_lat = z * math.sin(theta) + 0.006 return [bd_lng, bd_lat] def bd09togcj02(bd_lon, bd_lat): \u0026#34;\u0026#34;\u0026#34; 百度坐标系(BD-09)转火星坐标系(GCJ-02) 百度——\u0026gt;谷歌、高德 :param bd_lat:百度坐标纬度 :param bd_lon:百度坐标经度 :return:转换后的坐标列表形式 \u0026#34;\u0026#34;\u0026#34; x = bd_lon - 0.0065 y = bd_lat - 0.006 z = math.sqrt(x * x + y * y) - 0.00002 * math.sin(y * x_pi) theta = math.atan2(y, x) - 0.000003 * math.cos(x * x_pi) gg_lng = z * math.cos(theta) gg_lat = z * math.sin(theta) return [gg_lng, gg_lat] def wgs84togcj02(lng, lat): \u0026#34;\u0026#34;\u0026#34; WGS84转GCJ02(火星坐标系) :param lng:WGS84坐标系的经度 :param lat:WGS84坐标系的纬度 :return: \u0026#34;\u0026#34;\u0026#34; if out_of_china(lng, lat): # 判断是否在国内 return lng, lat dlat = transformlat(lng - 105.0, lat - 35.0) dlng = transformlng(lng - 105.0, lat - 35.0) radlat = lat / 180.0 * pi magic = math.sin(radlat) magic = 1 - ee * magic * magic sqrtmagic = math.sqrt(magic) dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi) dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi) mglat = lat + dlat mglng = lng + dlng return [mglng, mglat] def gcj02towgs84(lng, lat): \u0026#34;\u0026#34;\u0026#34; GCJ02(火星坐标系)转GPS84 :param lng:火星坐标系的经度 :param lat:火星坐标系纬度 :return: \u0026#34;\u0026#34;\u0026#34; if out_of_china(lng, lat): return lng, lat dlat = transformlat(lng - 105.0, lat - 35.0) dlng = transformlng(lng - 105.0, lat - 35.0) radlat = lat / 180.0 * pi magic = math.sin(radlat) magic = 1 - ee * magic * magic sqrtmagic = math.sqrt(magic) dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * pi) dlng = (dlng * 180.0) / (a / sqrtmagic * math.cos(radlat) * pi) mglat = lat + dlat mglng = lng + dlng return [lng * 2 - mglng, lat * 2 - mglat] def transformlat(lng, lat): ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + \\ 0.1 * lng * lat + 0.2 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lat * pi) + 40.0 * math.sin(lat / 3.0 * pi)) * 2.0 / 3.0 ret += (160.0 * math.sin(lat / 12.0 * pi) + 320 * math.sin(lat * pi / 30.0)) * 2.0 / 3.0 return ret def transformlng(lng, lat): ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + \\ 0.1 * lng * lat + 0.1 * math.sqrt(math.fabs(lng)) ret += (20.0 * math.sin(6.0 * lng * pi) + 20.0 * math.sin(2.0 * lng * pi)) * 2.0 / 3.0 ret += (20.0 * math.sin(lng * pi) + 40.0 * math.sin(lng / 3.0 * pi)) * 2.0 / 3.0 ret += (150.0 * math.sin(lng / 12.0 * pi) + 300.0 * math.sin(lng / 30.0 * pi)) * 2.0 / 3.0 return ret def out_of_china(lng, lat): \u0026#34;\u0026#34;\u0026#34; 判断是否在国内，不在国内不做偏移 :param lng: :param lat: :return: \u0026#34;\u0026#34;\u0026#34; if lng \u0026lt; 72.004 or lng \u0026gt; 137.8347: return True if lat \u0026lt; 0.8293 or lat \u0026gt; 55.8271: return True return False if __name__ == \u0026#39;__main__\u0026#39;: lng = 128.543 lat = 37.065 result1 = gcj02tobd09(lng, lat) result2 = bd09togcj02(lng, lat) result3 = wgs84togcj02(lng, lat) result4 = gcj02towgs84(lng, lat) result5 = geocode(\u0026#39;北京市朝阳区朝阳公园\u0026#39;) print(result1, \u0026#39;\\n\u0026#39;, result2, \u0026#39;\\n\u0026#39;, result3, \u0026#39;\\n\u0026#39;, result4, \u0026#39;\\n\u0026#39;, result5) ","date":"2021-02-05T13:13:42+08:00","permalink":"https://blog.ionosphere.site/p/2a125715/","title":"坐标系转换"},{"content":"实现步骤  整体逻辑：使用GitHub仓库作为存储空间，利用jsdeliver做CDN，利用PicGo做图片管理工具\n 1. Github设置  创建公开仓库 创建私人访问Token,并将Token记录下来   注意：Token需要有repo、delete_repo权限\n 2. PicGo设置 配置如下\n资源 PicGo\njsDelivr\n","date":"2021-02-04T17:09:16+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210204215131.png","permalink":"https://blog.ionosphere.site/p/4063f65b/","title":"Github+PicGo+jsdeliver搭建图床"},{"content":" 转载自：Windows下Oracle定时备份(全量备份)\n 关于Windows下oracle全量备份的文章，很多网站都有，写下本文不过是为了以后方便查找，不用再到处找。以下些许内容有所参考到其他人所写内容，这里无意冒犯，本文引用内容部分会附上参考地址，还望原作者见谅。\n备份脚本 新建txt文档，把脚本复制进去后改文件格式为bat文件，双击运行即可测试该脚本是否有误。这里要说明一下，开始把脚本拿过来执行时，一直未能成功备份数据库,用bat的pause暂停调试发现了一些问题，有时不注意可能会在定义,变量如BACKUPDATE、USER等后面带了空格,这个时候问题就来了，导致参数的不正确，所以这里需注意！\n@echo off echo ================================================ echo Windows环境下Oracle数据库的自动备份脚本 echo 1. 使用当前日期命名备份文件。 echo 2. 自动删除7天前的备份。 echo ================================================ echo 以“YYYYMMDD”格式取出当前时间。 set BACKUPDATE=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2% echo 设置用户名、密码和要备份的数据库 set USER=ora_user set PASSWORD=ora_name set DATABASE=conn_db echo 创建备份目录 if not exist \u0026#34;E:\\backup\\data\u0026#34; mkdir E:\\backup\\data if not exist \u0026#34;E:\\backup\\log\u0026#34; mkdir E:\\backup\\log set DATADIR=E:\\backup\\data set LOGDIR=E:\\backup\\log exp %USER%/%PASSWORD%@%DATABASE% file=%DATADIR%\\data_%BACKUPDATE%.dmp log=%LOGDIR%\\log_%BACKUPDATE%.log echo 删除7天前的备份。 forfiles /p \u0026#34;%DATADIR%\u0026#34; /s /m *.* /d -7 /c \u0026#34;cmd /c del @path\u0026#34; forfiles /p \u0026#34;%LOGDIR%\u0026#34; /s /m *.* /d -7 /c \u0026#34;cmd /c del @path\u0026#34; exit  注：该脚本参考Windows环境下Oracle数据库的自动备份脚本\n 定时任务 这里需要用到Windows的【任务计划程序】，操作按照下列截图一一操作。\n快捷查询 选择任务计划程序 创建基本任务 填写任务相关信息 定时任务描述 任务执行时间 选择刚刚写的数据库备份脚本\n最后在任务列表里可以看到刚刚创建的定时任务，那么这个任务从设定的时间开始则会每天执行一次，即达到定时备份任务了\n 注：以上内容参考 定时备份ORACLE数据库(windows环境下)\n 脚本 定时备份.txt\n","date":"2020-12-25T14:38:32+08:00","permalink":"https://blog.ionosphere.site/p/22637e0b/","title":"Oracle定时备份"},{"content":"# 文字转语音 say -f 1.txt -o 1.aiff say 你好 -o 你好.aiff # 音频格式转换 ffmpeg -f aiff -i 你好.aiff 你好.mp3 ","date":"2020-10-06T13:48:54+08:00","permalink":"https://blog.ionosphere.site/p/0272ad7a/","title":"文字转语音"},{"content":"\r\r\r","date":"2020-08-20T11:26:07+08:00","permalink":"https://blog.ionosphere.site/p/a39f146f/","title":"黑神话·悟空"},{"content":"","date":"2020-08-06T21:35:01+08:00","permalink":"https://blog.ionosphere.site/p/4a241902/","title":"今天天气很是不错..."},{"content":" Homebrew\n 查看已安装的包 查看已经安装的包\nbrew list 更新Homebrew 更新Homebrew(此命令会显示可以更新的包列表，已安装的包会有对号)\nbrew update 列出可更新的包 # 不包含含自动更新的包 brew outdated # 含自动更新的包 brew cask outdated --greedy 安装更新 brew upgrade 清理旧版本 # 查看可清理的包列表 brew cleanup -n # 清理旧版本包 brew cleanup # 清理早于3天的无用的symlink，且清理与之相关的位于/Applications和~/Applications中的无用App链接 brew cleanup --prune 3 ","date":"2020-07-06T13:46:40+08:00","permalink":"https://blog.ionosphere.site/p/319d5434/","title":"Homebrew"},{"content":"命令 # 查看系统激活状态 slmgr.vbs -xpr # 查看系统激活状态详细信息 slmgr.vbs -dlv # 安装产品密钥（企业版Key） slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX # 设置KMS服务器 slmgr /skms 192.168.31.57:1688 # 自动激活 slmgr /ato 密钥 W269N-WFGWX-YVC9B-4J6C9-T83GX 资源 KMS服务器\n","date":"2019-08-13T13:54:20+08:00","permalink":"https://blog.ionosphere.site/p/acf0469c/","title":"Windows KMS激活"},{"content":"","date":"2018-11-04T03:10:03+08:00","permalink":"https://blog.ionosphere.site/p/14cff628/","title":"拿到 [真·大师剑] 了"},{"content":"","date":"2018-09-16T15:49:07+08:00","permalink":"https://blog.ionosphere.site/p/0b3c6886/","title":"一种从天而降的棒法"},{"content":"","date":"2018-09-14T22:58:33+08:00","permalink":"https://blog.ionosphere.site/p/ca48c2fa/","title":"目击了一条龙"},{"content":"   \n","date":"2018-03-10T21:04:54+08:00","image":"https://cdn.jsdelivr.net/gh/io-oss/NetDisk/img/20210228015926.jpeg","permalink":"https://blog.ionosphere.site/p/343d7f9e/","title":"西山国家森林公园灵山风景区"}]